{"ast":null,"code":"import * as React from \"react\";\nimport { useEventCallback } from \"../../hooks/index.js\";\nimport { useTimeouts } from \"../../contexts/index.js\";\nimport { SwipeState } from \"./index.js\";\nimport { EVENT_ON_WHEEL } from \"../../consts.js\";\nexport var useWheelSwipe = function useWheelSwipe(swipeState, subscribeSensors, isSwipeValid, containerWidth, swipeAnimationDuration, onSwipeStart, onSwipeProgress, onSwipeFinish, onSwipeCancel) {\n  var offset = React.useRef(0);\n  var intent = React.useRef(0);\n  var intentCleanup = React.useRef();\n  var resetCleanup = React.useRef();\n  var wheelResidualMomentum = React.useRef(0);\n  var startTime = React.useRef(0);\n  var _useTimeouts = useTimeouts(),\n    setTimeout = _useTimeouts.setTimeout,\n    clearTimeout = _useTimeouts.clearTimeout;\n  var cancelSwipeIntentCleanup = React.useCallback(function () {\n    if (intentCleanup.current) {\n      clearTimeout(intentCleanup.current);\n      intentCleanup.current = undefined;\n    }\n  }, [clearTimeout]);\n  var cancelSwipeResetCleanup = React.useCallback(function () {\n    if (resetCleanup.current) {\n      clearTimeout(resetCleanup.current);\n      resetCleanup.current = undefined;\n    }\n  }, [clearTimeout]);\n  var handleCleanup = useEventCallback(function () {\n    if (swipeState !== SwipeState.SWIPE) {\n      offset.current = 0;\n      startTime.current = 0;\n      cancelSwipeIntentCleanup();\n      cancelSwipeResetCleanup();\n    }\n  });\n  React.useEffect(handleCleanup, [swipeState, handleCleanup]);\n  var handleCancelSwipe = useEventCallback(function (currentSwipeOffset) {\n    resetCleanup.current = undefined;\n    if (offset.current === currentSwipeOffset) {\n      onSwipeCancel(offset.current);\n    }\n  });\n  var onWheel = useEventCallback(function (event) {\n    if (event.ctrlKey) {\n      return;\n    }\n    if (Math.abs(event.deltaY) > Math.abs(event.deltaX)) {\n      return;\n    }\n    if (!swipeState) {\n      if (Math.abs(event.deltaX) <= 1.2 * Math.abs(wheelResidualMomentum.current)) {\n        wheelResidualMomentum.current = event.deltaX;\n        return;\n      }\n      if (!isSwipeValid(-event.deltaX)) {\n        return;\n      }\n      intent.current += event.deltaX;\n      cancelSwipeIntentCleanup();\n      if (Math.abs(intent.current) > 30) {\n        intent.current = 0;\n        wheelResidualMomentum.current = 0;\n        startTime.current = Date.now();\n        onSwipeStart();\n      } else {\n        var currentSwipeIntent = intent.current;\n        intentCleanup.current = setTimeout(function () {\n          intentCleanup.current = undefined;\n          if (currentSwipeIntent === intent.current) {\n            intent.current = 0;\n          }\n        }, swipeAnimationDuration);\n      }\n    } else if (swipeState === SwipeState.SWIPE) {\n      var newSwipeOffset = offset.current - event.deltaX;\n      newSwipeOffset = Math.min(Math.abs(newSwipeOffset), containerWidth) * Math.sign(newSwipeOffset);\n      offset.current = newSwipeOffset;\n      onSwipeProgress(newSwipeOffset);\n      cancelSwipeResetCleanup();\n      if (Math.abs(newSwipeOffset) > 0.2 * containerWidth) {\n        wheelResidualMomentum.current = event.deltaX;\n        onSwipeFinish(newSwipeOffset, Date.now() - startTime.current);\n        return;\n      }\n      resetCleanup.current = setTimeout(function () {\n        return handleCancelSwipe(newSwipeOffset);\n      }, 2 * swipeAnimationDuration);\n    } else {\n      wheelResidualMomentum.current = event.deltaX;\n    }\n  });\n  React.useEffect(function () {\n    return subscribeSensors(EVENT_ON_WHEEL, onWheel);\n  }, [subscribeSensors, onWheel]);\n};","map":{"version":3,"names":["React","useEventCallback","useTimeouts","SwipeState","EVENT_ON_WHEEL","useWheelSwipe","swipeState","subscribeSensors","isSwipeValid","containerWidth","swipeAnimationDuration","onSwipeStart","onSwipeProgress","onSwipeFinish","onSwipeCancel","offset","useRef","intent","intentCleanup","resetCleanup","wheelResidualMomentum","startTime","setTimeout","clearTimeout","cancelSwipeIntentCleanup","useCallback","current","undefined","cancelSwipeResetCleanup","handleCleanup","SWIPE","useEffect","handleCancelSwipe","currentSwipeOffset","onWheel","event","ctrlKey","Math","abs","deltaY","deltaX","Date","now","currentSwipeIntent","newSwipeOffset","min","sign"],"sources":["C:/AAA Kithmina/Education/SLIIT/Year 3/Y3S1/Disributed Systems - SE3020/Assignments/01/Project/Collaborative-shopping-platform/frontend/node_modules/yet-another-react-lightbox/dist/core/modules/controller/useWheelSwipe.js"],"sourcesContent":["import * as React from \"react\";\nimport { useEventCallback } from \"../../hooks/index.js\";\nimport { useTimeouts } from \"../../contexts/index.js\";\nimport { SwipeState } from \"./index.js\";\nimport { EVENT_ON_WHEEL } from \"../../consts.js\";\nexport const useWheelSwipe = (swipeState, subscribeSensors, isSwipeValid, containerWidth, swipeAnimationDuration, onSwipeStart, onSwipeProgress, onSwipeFinish, onSwipeCancel) => {\n    const offset = React.useRef(0);\n    const intent = React.useRef(0);\n    const intentCleanup = React.useRef();\n    const resetCleanup = React.useRef();\n    const wheelResidualMomentum = React.useRef(0);\n    const startTime = React.useRef(0);\n    const { setTimeout, clearTimeout } = useTimeouts();\n    const cancelSwipeIntentCleanup = React.useCallback(() => {\n        if (intentCleanup.current) {\n            clearTimeout(intentCleanup.current);\n            intentCleanup.current = undefined;\n        }\n    }, [clearTimeout]);\n    const cancelSwipeResetCleanup = React.useCallback(() => {\n        if (resetCleanup.current) {\n            clearTimeout(resetCleanup.current);\n            resetCleanup.current = undefined;\n        }\n    }, [clearTimeout]);\n    const handleCleanup = useEventCallback(() => {\n        if (swipeState !== SwipeState.SWIPE) {\n            offset.current = 0;\n            startTime.current = 0;\n            cancelSwipeIntentCleanup();\n            cancelSwipeResetCleanup();\n        }\n    });\n    React.useEffect(handleCleanup, [swipeState, handleCleanup]);\n    const handleCancelSwipe = useEventCallback((currentSwipeOffset) => {\n        resetCleanup.current = undefined;\n        if (offset.current === currentSwipeOffset) {\n            onSwipeCancel(offset.current);\n        }\n    });\n    const onWheel = useEventCallback((event) => {\n        if (event.ctrlKey) {\n            return;\n        }\n        if (Math.abs(event.deltaY) > Math.abs(event.deltaX)) {\n            return;\n        }\n        if (!swipeState) {\n            if (Math.abs(event.deltaX) <= 1.2 * Math.abs(wheelResidualMomentum.current)) {\n                wheelResidualMomentum.current = event.deltaX;\n                return;\n            }\n            if (!isSwipeValid(-event.deltaX)) {\n                return;\n            }\n            intent.current += event.deltaX;\n            cancelSwipeIntentCleanup();\n            if (Math.abs(intent.current) > 30) {\n                intent.current = 0;\n                wheelResidualMomentum.current = 0;\n                startTime.current = Date.now();\n                onSwipeStart();\n            }\n            else {\n                const currentSwipeIntent = intent.current;\n                intentCleanup.current = setTimeout(() => {\n                    intentCleanup.current = undefined;\n                    if (currentSwipeIntent === intent.current) {\n                        intent.current = 0;\n                    }\n                }, swipeAnimationDuration);\n            }\n        }\n        else if (swipeState === SwipeState.SWIPE) {\n            let newSwipeOffset = offset.current - event.deltaX;\n            newSwipeOffset = Math.min(Math.abs(newSwipeOffset), containerWidth) * Math.sign(newSwipeOffset);\n            offset.current = newSwipeOffset;\n            onSwipeProgress(newSwipeOffset);\n            cancelSwipeResetCleanup();\n            if (Math.abs(newSwipeOffset) > 0.2 * containerWidth) {\n                wheelResidualMomentum.current = event.deltaX;\n                onSwipeFinish(newSwipeOffset, Date.now() - startTime.current);\n                return;\n            }\n            resetCleanup.current = setTimeout(() => handleCancelSwipe(newSwipeOffset), 2 * swipeAnimationDuration);\n        }\n        else {\n            wheelResidualMomentum.current = event.deltaX;\n        }\n    });\n    React.useEffect(() => subscribeSensors(EVENT_ON_WHEEL, onWheel), [subscribeSensors, onWheel]);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}